#define DEBUG
/*
 * wm2000.c  --  WM2000 ALSA Soc Audio driver
 *
 * Copyright 2008-2010 Wolfson Microelectronics PLC.
 *
 * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * The download image for the WM2000 will be requested as
 * 'wm2000_anc.bin' by default (overridable via platform data) at
 * runtime and is expected to be in flat binary format.  This is
 * generated by Wolfson configuration tools and includes
 * system-specific callibration information.  If supplied as a
 * sequence of ASCII-encoded hexidecimal bytes this can be converted
 * into a flat binary with a command such as this on the command line:
 *
 * perl -e 'while (<>) { s/[\r\n]+// ; printf("%c", hex($_)); }'
 *                 < file  > wm2000_anc.bin
 */

#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/firmware.h>
#include <linux/delay.h>
#include <linux/pm.h>
#include <linux/i2c.h>
#include <linux/regmap.h>
#include <linux/debugfs.h>
#include <linux/slab.h>
#include <sound/core.h>
#include <sound/pcm.h>
#include <sound/pcm_params.h>
#include <sound/soc.h>
#include <sound/initval.h>
#include <sound/tlv.h>
#include <linux/gpio.h>
#include <asm/intel_scu_ipc.h>
#include <asm/intel_scu_ipcutil.h>

#include <sound/wm2000.h>

#include "wm2000.h"

enum wm2000_anc_mode {
	ANC_ACTIVE = 0,
	ANC_BYPASS = 1,
	ANC_STANDBY = 2,
	ANC_OFF = 3,
};

struct wm2000_priv {
	struct i2c_client *i2c;
	struct regmap *regmap;

	struct mutex anc_lock;
	enum wm2000_anc_mode anc_mode;

	unsigned int anc_active:1;
	unsigned int anc_eng_ena:1;
	unsigned int spk_ena:1;
	unsigned int incall_mode:1;

	unsigned int mclk_div:1;
	unsigned int speech_clarity:1;

	int anc_download_size;
	char *anc_download;
};
static int wm2000_id = 0;
static int wm2000_id_parm_set(const char *val, struct kernel_param *kp)
{
	param_set_int(val, kp);
	return 0;
}
module_param_call(wm2000_id, wm2000_id_parm_set, param_get_int, &wm2000_id, S_IRUGO);

//#define WM2000_GPIO_ENABLE /* K5 EVB need gpio49 to enable VDD2.8*/
#ifdef WM2000_GPIO_ENABLE
#define GPIO_WM2000_EN	(49)
static void wm2000_gpio_request()
{
	int ret;

	ret = gpio_request(GPIO_WM2000_EN, "wm2000_enable_ldo");
	if (ret) {
		printk("###enter %s, failed to request gpio 49\n", __func__);
	}
	ret = gpio_direction_output(GPIO_WM2000_EN, 1);
	if (ret) {
		printk("###enter %s, gpio failed to output 1\n", __func__);
	}
	return;
}
#endif

static int wm2000_clk_ref;

static void wm2000_clk_enable(void)
{
	wm2000_clk_ref++;
	pr_debug("wm2000: clock refcount %d\n", wm2000_clk_ref);
    intel_scu_ipc_set_osc_clk0(true, CLK0_MSIC);
}

static void wm2000_clk_disable(void)
{
	wm2000_clk_ref--;
	pr_debug("wm2000: clock refcount %d\n", wm2000_clk_ref);
	if (!wm2000_clk_ref)
	    intel_scu_ipc_set_osc_clk0(false, CLK0_MSIC);
}

static int wm2000_write(struct i2c_client *i2c, unsigned int reg,
			unsigned int value)
{
	struct wm2000_priv *wm2000 = i2c_get_clientdata(i2c);
	return regmap_write(wm2000->regmap, reg, value);
}

static unsigned int wm2000_read(struct i2c_client *i2c, unsigned int r)
{
	struct wm2000_priv *wm2000 = i2c_get_clientdata(i2c);
	unsigned int val;
	int ret;

	ret = regmap_read(wm2000->regmap, r, &val);
	if (ret < 0)
		return -1;

	return val;
}

static void wm2000_reset(struct wm2000_priv *wm2000)
{
	struct i2c_client *i2c = wm2000->i2c;

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);
	wm2000_write(i2c, WM2000_REG_ID1, 0);

	wm2000->anc_mode = ANC_OFF;
}

static int wm2000_poll_bit(struct i2c_client *i2c,
			   unsigned int reg, u8 mask, int timeout)
{
	int val;

	val = wm2000_read(i2c, reg);

	while (!(val & mask) && --timeout) {
		msleep(1);
		val = wm2000_read(i2c, reg);
	}

	if (timeout == 0)
		return 0;
	else
		return 1;
}

static int wm2000_power_up(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);
	int ret, timeout;
       int retry_times = 3;
	int value;

	WARN_ON(wm2000->anc_mode != ANC_OFF);

	dev_dbg(&i2c->dev, "Beginning power up\n");

	wm2000_clk_enable();

	if (!wm2000->mclk_div) {
		dev_dbg(&i2c->dev, "Disabling MCLK divider\n");
		wm2000_write(i2c, WM2000_REG_SYS_CTL2,
			     WM2000_MCLK_DIV2_ENA_CLR);
	} else {
		dev_dbg(&i2c->dev, "Enabling MCLK divider\n");
		wm2000_write(i2c, WM2000_REG_SYS_CTL2,
			     WM2000_MCLK_DIV2_ENA_SET);
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_SET);

	/* Wait for ANC engine to become ready */
	if (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,
			     WM2000_ANC_ENG_IDLE, 1)) {
		dev_err(&i2c->dev, "ANC engine failed to reset\n");
		return -ETIMEDOUT;
	}

	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_BOOT_COMPLETE, 1)) {
		dev_err(&i2c->dev, "ANC engine failed to initialise\n");
		return -ETIMEDOUT;
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);

retry:
	/* Open code download of the data since it is the only bulk
	 * write we do. */
	dev_dbg(&i2c->dev, "Downloading %d bytes\n",
		wm2000->anc_download_size - 2);

	ret = i2c_master_send(i2c, wm2000->anc_download,
			      wm2000->anc_download_size);
	if (ret < 0) {
		dev_err(&i2c->dev, "i2c_transfer() failed: %d\n", ret);
        if (retry_times--) {
            goto retry;
        }
		return ret;
	}
	if (ret != wm2000->anc_download_size) {
		dev_err(&i2c->dev, "i2c_transfer() failed, %d != %d\n",
			ret, wm2000->anc_download_size);
		return -EIO;
	}

	dev_dbg(&i2c->dev, "Download complete\n");

	ret = wm2000_read(i2c, WM2000_REG_ANC_GAIN_CTRL);
	printk("wm2000 anc gain:0x%x\n", ret);
	wm2000_write(i2c, WM2000_REG_ANC_GAIN_CTRL, 42); // Add for ANC gain adjustment, 126: big gain 58:-3dB,
//	wm2000_write(i2c, WM2000_REG_MSE_TH2, 0x08); // 0x08:55dBSPL, 0x90:80dBSPL
//	wm2000_write(i2c, WM2000_REG_MSE_TH1, 0x04); // 0x04:55dBSPL, 0x48:74dBSPL

	if (analogue) {
		timeout = 248;
		wm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 1);

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	} else {
		timeout = 10;

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	}

	ret = wm2000_read(i2c, WM2000_REG_SPEECH_CLARITY);
	if (wm2000->speech_clarity) {
	        dev_dbg(&i2c->dev, "Disabling Speech Clarity\n");
		ret &= ~WM2000_SPEECH_CLARITY;
	}
	else {
	        dev_dbg(&i2c->dev, "Enabling Speech Clarity\n");
		ret |= WM2000_SPEECH_CLARITY;
	}
	wm2000_write(i2c, WM2000_REG_SPEECH_CLARITY, ret);

	wm2000_write(i2c, WM2000_REG_SYS_START0, 0x33);
	wm2000_write(i2c, WM2000_REG_SYS_START1, 0x02);

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	dev_dbg(&i2c->dev, "ANC active\n");
	if (analogue)
		dev_dbg(&i2c->dev, "Analogue active\n");

	/*keep WM2000_REG_SPK_CTL default output off*/
	value = wm2000_read(i2c, WM2000_REG_SPK_CTL);
	value &= 0xfe;
	wm2000_write(i2c, WM2000_REG_SPK_CTL, value);

	wm2000->anc_mode = ANC_ACTIVE;

	return 0;
}

static int wm2000_power_down(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);
	int timeout;

	dev_dbg(&i2c->dev, "Power Down\n");
	if (analogue) {
		timeout = 248;
		wm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 1);
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_POWER_DOWN);
	} else {
		timeout = 10;
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_POWER_DOWN);
	}

	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_POWER_DOWN_COMPLETE, timeout)) {
		dev_err(&i2c->dev, "Timeout waiting for ANC power down\n");
        goto anc_off_timeout;
//		return -ETIMEDOUT;
	}

	if (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,
			     WM2000_ANC_ENG_IDLE, 1)) {
		dev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");
		return -ETIMEDOUT;
	}

anc_off_timeout:
	dev_dbg(&i2c->dev, "powered off\n");
	wm2000->anc_mode = ANC_OFF;

	wm2000_clk_disable();

	return 0;
}

static int wm2000_enter_bypass_from_standby(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	wm2000_clk_enable();
	dev_dbg(&i2c->dev, "enter bypass from standby\n");
	wm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);

    wm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 1);
	if (analogue) {
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_BYPASS_ENTRY);
	} else {
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_BYPASS_ENTRY);
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	wm2000->anc_mode = ANC_BYPASS;
	dev_dbg(&i2c->dev, "bypass from standby enabled\n");

	return 0;
}

static int wm2000_enter_bypass(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	dev_dbg(&i2c->dev, "enter bypass\n");
	WARN_ON(wm2000->anc_mode != ANC_ACTIVE);

	/* Make sure power up completed */
	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_MOUSE_ACTIVE, 4000)) {
		dev_err(&i2c->dev, "Timed out waiting for device after %dms\n",
			4000 * 10);
		return -ETIMEDOUT;
	}

	if (analogue) {
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_BYPASS_ENTRY);
	} else {
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_BYPASS_ENTRY);
	}

	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
				     WM2000_STATUS_BYPASS_COMPLETE, 100)) {
			dev_err(&i2c->dev, "Timeout waiting for BYPASS complete\n");
			return -ETIMEDOUT;
		}

	wm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);

	wm2000->anc_mode = ANC_BYPASS;
	dev_dbg(&i2c->dev, "bypass enabled\n");

	return 0;
}

static int wm2000_exit_bypass(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	dev_dbg(&i2c->dev, "exit bypass\n");
	WARN_ON(wm2000->anc_mode != ANC_BYPASS);

	wm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);

	/*Make sure wm2000 bypass complete*/
	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_BYPASS_COMPLETE, 100)) {
		dev_err(&i2c->dev, "Timeout waiting for BYPASS complete\n");
		return -ETIMEDOUT;
	}

	if (analogue) {
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	} else {
		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_MOUSE_ENABLE |
			     WM2000_MODE_THERMAL_ENABLE);
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	wm2000->anc_mode = ANC_ACTIVE;
	dev_dbg(&i2c->dev, "MOUSE active\n");

	return 0;
}

static int wm2000_enter_standby_from_bypass(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);
	int timeout;

	dev_dbg(&i2c->dev, "enter standby from bypass\n");

	// bring system out of stanby
	wm2000_write(i2c, WM2000_REG_SYS_CTL1, 0); // clear standby bit
	// enable RAM before writing any thing to ram
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);
	wm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 1);

    /*Make sure wm2000 bypass complete*/
	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_BYPASS_COMPLETE, 100)) {
		dev_err(&i2c->dev, "Timeout waiting for BYPASS complete\n");
		return -ETIMEDOUT;
	}

	if (analogue) {
		dev_dbg(&i2c->dev, "enter standby analog=1\n");
		timeout = 248;
		wm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 1);

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_STANDBY_ENTRY);
	} else {
		dev_dbg(&i2c->dev, "enter standby analog=0\n");
		timeout = 10;

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_STANDBY_ENTRY);
	}

	// wake up ANC engine
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

	timeout = 1000;
	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_STANDBY_COMPLETE, timeout)) {
		dev_err(&i2c->dev,
			"Timed out waiting for WM2000_STATUS_STANDBY_COMPLETE after %dms\n", timeout);
		return -ETIMEDOUT;
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);

	wm2000->anc_mode = ANC_STANDBY;
	dev_dbg(&i2c->dev, "standby from bypass\n");
	if (analogue)
		dev_dbg(&i2c->dev, "Analogue disabled\n");

	wm2000_clk_disable();

	return 0;
}

static int wm2000_enter_standby(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);
	int timeout = 4000;

	dev_dbg(&i2c->dev, "enter standby\n");
	WARN_ON(wm2000->anc_mode != ANC_ACTIVE);

	/* Make sure power up completed */
	if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_MOUSE_ACTIVE, timeout)) {
		dev_err(&i2c->dev, "Timed out waiting for device after %dms\n",
			timeout * 10);
		return -ETIMEDOUT;
	}

	if (analogue) {
		dev_dbg(&i2c->dev, "enter standby analog=1\n");
		timeout = 248;
		wm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 1);

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_STANDBY_ENTRY);
	} else {
		dev_dbg(&i2c->dev, "enter standby analog=0\n");
		timeout = 10;

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_STANDBY_ENTRY);
	}

    if (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,
			     WM2000_STATUS_STANDBY_COMPLETE, timeout)) {
		dev_err(&i2c->dev,
			"Timed out waiting for ANC disable after 1ms\n");
		return -ETIMEDOUT;
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);

	wm2000->anc_mode = ANC_STANDBY;
	dev_dbg(&i2c->dev, "standby\n");
	if (analogue)
		dev_dbg(&i2c->dev, "Analogue disabled\n");

	wm2000_clk_disable();

	return 0;
}

static int wm2000_exit_standby(struct i2c_client *i2c, int analogue)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);
	int timeout;
    int value;

	dev_dbg(&i2c->dev, "exit standby\n");
	WARN_ON(wm2000->anc_mode != ANC_STANDBY);

	wm2000_clk_enable();

	wm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);

	if (analogue) {
		timeout = 248;
		wm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 1);

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_ANA_SEQ_INCLUDE |
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_MOUSE_ENABLE);
	} else {
		timeout = 100;

		wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
			     WM2000_MODE_THERMAL_ENABLE |
			     WM2000_MODE_MOUSE_ENABLE);
	}

	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);
	wm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);

      /*keep WM2000_REG_SPK_CTL default output off*/
	value = wm2000_read(i2c, WM2000_REG_SPK_CTL);
	value &= 0xfe;
	wm2000_write(i2c, WM2000_REG_SPK_CTL, value);
	value = wm2000_read(i2c, WM2000_REG_SPK_CTL);
	dev_dbg(&i2c->dev,"wm2000 anc speaker get val 1 = %02x\n", value);

	wm2000->anc_mode = ANC_ACTIVE;
	dev_dbg(&i2c->dev, "MOUSE active\n");
	if (analogue)
		dev_dbg(&i2c->dev, "Analogue enabled\n");

	return 0;
}

typedef int (*wm2000_mode_fn)(struct i2c_client *i2c, int analogue);

static struct {
	enum wm2000_anc_mode source;
	enum wm2000_anc_mode dest;
	int analogue;
	wm2000_mode_fn step[2];
} anc_transitions[] = {
	{
		.source = ANC_OFF,
		.dest = ANC_ACTIVE,
		.analogue = 1,
		.step = {
			wm2000_power_up,
		},
	},
	{
		.source = ANC_OFF,
		.dest = ANC_STANDBY,
		.step = {
			wm2000_power_up,
			wm2000_enter_standby,
		},
	},
	{
		.source = ANC_OFF,
		.dest = ANC_BYPASS,
		.analogue = 1,
		.step = {
			wm2000_power_up,
			wm2000_enter_bypass,
		},
	},
	{
		.source = ANC_ACTIVE,
		.dest = ANC_BYPASS,
		.analogue = 1,
		.step = {
			wm2000_enter_bypass,
		},
	},
	{
		.source = ANC_ACTIVE,
		.dest = ANC_STANDBY,
		.analogue = 1,
		.step = {
			wm2000_enter_standby,
		},
	},
	{
		.source = ANC_ACTIVE,
		.dest = ANC_OFF,
		.analogue = 1,
		.step = {
			wm2000_power_down,
		},
	},
	{
		.source = ANC_BYPASS,
		.dest = ANC_ACTIVE,
		.analogue = 1,
		.step = {
			wm2000_exit_bypass,
		},
	},
	{
		.source = ANC_BYPASS,
		.dest = ANC_STANDBY,
		.analogue = 1,
		.step = {
			wm2000_enter_standby_from_bypass,
		},
	},
	{
		.source = ANC_BYPASS,
		.dest = ANC_OFF,
		.step = {
			wm2000_exit_bypass,
			wm2000_power_down,
		},
	},
	{
		.source = ANC_STANDBY,
		.dest = ANC_ACTIVE,
		.analogue = 1,
		.step = {
			wm2000_exit_standby,
		},
	},
	{
		.source = ANC_STANDBY,
		.dest = ANC_BYPASS,
		.analogue = 1,
		.step = {
			wm2000_enter_bypass_from_standby,
		},
	},
	{
		.source = ANC_STANDBY,
		.dest = ANC_OFF,
		.step = {
			wm2000_exit_standby,
			wm2000_power_down,
		},
	},
};

static int wm2000_anc_transition(struct wm2000_priv *wm2000,
				 enum wm2000_anc_mode mode)
{
	struct i2c_client *i2c = wm2000->i2c;
	int i, j;
	int ret;

	dev_dbg(&i2c->dev, "anc transition\n");
	if (wm2000->anc_mode == mode)
		return 0;

	for (i = 0; i < ARRAY_SIZE(anc_transitions); i++)
		if (anc_transitions[i].source == wm2000->anc_mode &&
		    anc_transitions[i].dest == mode)
			break;
	if (i == ARRAY_SIZE(anc_transitions)) {
		dev_err(&i2c->dev, "No transition for %d->%d\n",
			wm2000->anc_mode, mode);
		return -EINVAL;
	}

	for (j = 0; j < ARRAY_SIZE(anc_transitions[j].step); j++) {
		dev_err(&i2c->dev, "anc_transitions[%d].step[%d]\n",
			i, j);
		if (!anc_transitions[i].step[j])
			break;
		ret = anc_transitions[i].step[j](i2c,
						 anc_transitions[i].analogue);
		if (ret != 0)
			return ret;
	}
       dev_dbg(&i2c->dev, "anc transition end\n");
	return 0;
}

static int wm2000_anc_set_mode(struct wm2000_priv *wm2000)
{
	struct i2c_client *i2c = wm2000->i2c;
	enum wm2000_anc_mode mode;
	int ret;

	mutex_lock(&wm2000->anc_lock);

#if 0
	if (wm2000->anc_eng_ena && wm2000->spk_ena)
		if (wm2000->anc_active)
			mode = ANC_ACTIVE;
		else
			mode = ANC_BYPASS;
	else
		mode = ANC_STANDBY;
#else

	if(wm2000->incall_mode)
		if(wm2000->anc_active)
                mode = ANC_ACTIVE;
		else
		 mode = ANC_BYPASS;
	else
		 mode = ANC_STANDBY;
#endif

	 dev_dbg(&i2c->dev, "Set mode %d (enabled %d, mute %d, active %d incall %d)\n",
		mode, wm2000->anc_eng_ena, !wm2000->spk_ena,
		wm2000->anc_active,wm2000->incall_mode);

	ret = wm2000_anc_transition(wm2000, mode);

	mutex_unlock(&wm2000->anc_lock);

	return ret;
}

static int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);

	printk("wm2000 anc  mode get\n");
	ucontrol->value.enumerated.item[0] = wm2000->anc_active;

	return 0;
}

static int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
	int anc_active = ucontrol->value.enumerated.item[0];

	printk("wm2000 anc mode put\n");
	if (anc_active > 1)
		return -EINVAL;

	wm2000->anc_active = anc_active;

	return wm2000_anc_set_mode(wm2000);
}

static int wm2000_anc_incall_mode_get(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);

	printk( "wm2000 anc incall mode get wm2000->incall_mode=%d\n",wm2000->incall_mode);
	ucontrol->value.enumerated.item[0] = wm2000->incall_mode;

	return 0;
}

static int wm2000_anc_incall_mode_put(struct snd_kcontrol *kcontrol,
			       struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
	int incall_active = ucontrol->value.enumerated.item[0];

	printk("wm2000 anc incall mode put incall_active=%d\n",incall_active);
	if (incall_active > 1)
		return -EINVAL;

	wm2000->incall_mode = incall_active;

	return wm2000_anc_set_mode(wm2000);
}

static int wm2000_speaker_get(struct snd_kcontrol *kcontrol,
			      struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
       struct i2c_client *i2c = wm2000->i2c;
	int val;

	dev_dbg(&i2c->dev,"wm2000 anc speaker get\n");
	ucontrol->value.enumerated.item[0] = wm2000->spk_ena;
	val = wm2000_read(i2c, WM2000_REG_SPK_CTL);
	if (wm2000->spk_ena)
		val |= 0x21;
	else
		val &= 0xfe;
	wm2000_write(i2c, WM2000_REG_SPK_CTL, val);
	return 0;
}

static int wm2000_speaker_put(struct snd_kcontrol *kcontrol,
			      struct snd_ctl_elem_value *ucontrol)
{
	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
	struct i2c_client *i2c = wm2000->i2c;

	int val = ucontrol->value.enumerated.item[0];

	if (val > 1)
		return -EINVAL;

	wm2000->spk_ena = val;
	val = wm2000_read(i2c, WM2000_REG_SPK_CTL);
	if (wm2000->spk_ena)
		val |= 0x21;
	else
		val &= 0xfe;
	wm2000_write(i2c, WM2000_REG_SPK_CTL, val);
	dev_dbg(&i2c->dev,"wm2000 anc speaker put val 2 = %02x\n", val);

	return 0;

	//return wm2000_anc_set_mode(wm2000);
}

const struct snd_kcontrol_new wm2000_controls[] = {
    SOC_SINGLE("ANC Gain", WM2000_REG_ANC_GAIN_CTRL, 0, 255, 0),
	SOC_SINGLE_BOOL_EXT("WM2000 ANC Switch", 0,
			    wm2000_anc_mode_get,
			    wm2000_anc_mode_put),
	SOC_SINGLE_BOOL_EXT("WM2000 Switch", 0,
			    wm2000_speaker_get,
			    wm2000_speaker_put),
	SOC_SINGLE_BOOL_EXT("WM2000 INCALL", 0,
			    wm2000_anc_incall_mode_get,
			    wm2000_anc_incall_mode_put),		    
};
EXPORT_SYMBOL_GPL(wm2000_controls);

static int wm2000_anc_power_event(struct snd_soc_dapm_widget *w,
				  struct snd_kcontrol *kcontrol, int event)
{
	struct snd_soc_codec *codec = w->codec;
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);

	if (SND_SOC_DAPM_EVENT_ON(event)) {
		wm2000->anc_eng_ena = 1;
		//printk( "wm2000 anc power event on\n");
	}

	if (SND_SOC_DAPM_EVENT_OFF(event)) {
		wm2000->anc_eng_ena = 0;
		//printk( "wm2000 anc power event off\n"); 
	}

	return wm2000_anc_set_mode(wm2000);
}

static const struct snd_soc_dapm_widget wm2000_dapm_widgets[] = {
/* Externally visible pins */
SND_SOC_DAPM_OUTPUT("SPKN"),
SND_SOC_DAPM_OUTPUT("SPKP"),

SND_SOC_DAPM_INPUT("LINN"),
SND_SOC_DAPM_INPUT("LINP"),

SND_SOC_DAPM_PGA_E("ANC Engine", SND_SOC_NOPM, 0, 0, NULL, 0,
		   wm2000_anc_power_event,
		   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
};

/* Target, Path, Source */
static const struct snd_soc_dapm_route wm2000_audio_map[] = {
	{ "SPKN", NULL, "ANC Engine" },
	{ "SPKP", NULL, "ANC Engine" },
	{ "ANC Engine", NULL, "LINN" },
	{ "ANC Engine", NULL, "LINP" },
};

#ifdef CONFIG_PM
static int wm2000_suspend(struct snd_soc_codec *codec)
{
    struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
    int ret;

    printk( "wm2000 anc power suspend\n");
    wm2000_clk_enable();
    ret = wm2000_anc_transition(wm2000, ANC_OFF);

	intel_scu_ipc_set_osc_clk0(false, CLK0_MSIC);
	wm2000_clk_ref = 0;
	pr_debug("wm2000: clock refcount %d\n", wm2000_clk_ref);
   // wm2000_clk_disable();

    return ret;
}

static int wm2000_resume(struct snd_soc_codec *codec)
{
    struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);
    int ret;

    printk( "wm2000 anc power resume\n");
    wm2000_clk_enable();
    ret = wm2000_anc_set_mode(wm2000);
    wm2000_clk_disable();

    return ret;
}
#else
#define wm2000_suspend NULL
#define wm2000_resume NULL
#endif

static bool wm2000_readable_reg(struct device *dev, unsigned int reg)
{
	switch (reg) {
	case WM2000_REG_SYS_START:
	case WM2000_REG_ANC_GAIN_CTRL:
	case WM2000_REG_MSE_TH2:
	case WM2000_REG_MSE_TH1:
	case WM2000_REG_SPEECH_CLARITY:
	case WM2000_REG_SYS_WATCHDOG:
	case WM2000_REG_ANA_VMID_PD_TIME:
	case WM2000_REG_ANA_VMID_PU_TIME:
	case WM2000_REG_CAT_FLTR_INDX:
	case WM2000_REG_CAT_GAIN_0:
	case WM2000_REG_SYS_STATUS:
	case WM2000_REG_SYS_MODE_CNTRL:
	case WM2000_REG_SYS_START0:
	case WM2000_REG_SYS_START1:
	case WM2000_REG_ID1:
	case WM2000_REG_ID2:
	case WM2000_REG_REVISON:
	case WM2000_REG_SYS_CTL1:
	case WM2000_REG_SYS_CTL2:
	case WM2000_REG_ANC_STAT:
	case WM2000_REG_IF_CTL:
	case WM2000_REG_ANA_MIC_CTL:
	case WM2000_REG_SPK_CTL:
		return true;
	default:
		return false;
	}
}

static const struct regmap_config wm2000_regmap = {
	.reg_bits = 16,
	.val_bits = 8,

	.max_register = WM2000_REG_SPK_CTL,
	.readable_reg = wm2000_readable_reg,
};

static int wm2000_probe(struct snd_soc_codec *codec)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);

    codec->control_data = wm2000->regmap;
    snd_soc_codec_set_cache_io(codec, 16, 8, SND_SOC_REGMAP);

	printk("wm2000 wm2000 probe\n");
	/* This will trigger a transition to standby mode by default */
	wm2000_anc_set_mode(wm2000);

	return 0;
}

static int wm2000_remove(struct snd_soc_codec *codec)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);

	return wm2000_anc_transition(wm2000, ANC_OFF);
}

static struct snd_soc_codec_driver soc_codec_dev_wm2000 = {
	.probe = wm2000_probe,
	.remove = wm2000_remove,
	.suspend = wm2000_suspend,
	.resume = wm2000_resume,

	.dapm_widgets = wm2000_dapm_widgets,
	.num_dapm_widgets = ARRAY_SIZE(wm2000_dapm_widgets),
	.dapm_routes = wm2000_audio_map,
	.num_dapm_routes = ARRAY_SIZE(wm2000_audio_map),
	.controls = wm2000_controls,
	.num_controls = ARRAY_SIZE(wm2000_controls),
};

static int __devinit wm2000_i2c_probe(struct i2c_client *i2c,
				      const struct i2c_device_id *i2c_id)
{
	struct wm2000_priv *wm2000;
	struct wm2000_platform_data *pdata;
	const char *filename;
	const struct firmware *fw = NULL;
	int ret;
	int reg;
	u16 id;

#ifdef WM2000_GPIO_ENABLE
	wm2000_gpio_request();
#endif

	wm2000 = devm_kzalloc(&i2c->dev, sizeof(struct wm2000_priv),
			      GFP_KERNEL);
	if (wm2000 == NULL) {
		dev_err(&i2c->dev, "Unable to allocate private data\n");
		return -ENOMEM;
	}

	dev_set_drvdata(&i2c->dev, wm2000);
	mutex_init(&wm2000->anc_lock);

	wm2000->regmap = regmap_init_i2c(i2c, &wm2000_regmap);
	if (IS_ERR(wm2000->regmap)) {
		ret = PTR_ERR(wm2000->regmap);
		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
			ret);
		goto err;
	}

    /* when the system reboot, the power supply of wm2000 is always supplied,
     * so there is the bug solution below, powerdown and powerup the module before
     * probed!
     */
    ret=wm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);
    ret=wm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 1);
    ret=wm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,
            WM2000_MODE_ANA_SEQ_INCLUDE |
            WM2000_MODE_THERMAL_ENABLE |
            WM2000_MODE_MOUSE_ENABLE);

	/* Verify that this is a WM2000 */
	reg = wm2000_read(i2c, WM2000_REG_ID1);
	id = reg << 8;
	reg = wm2000_read(i2c, WM2000_REG_ID2);
	id |= reg & 0xff;

	if (id != 0x2000) {
		dev_err(&i2c->dev, "Device is not a WM2000 - ID %x\n", id);
		wm2000_id = 0;
		ret = -ENODEV;
		goto out_regmap_exit;
	} else 
		wm2000_id = 2000;
	printk("wm2000_id = 0x%x\n", id);

	reg = wm2000_read(i2c, WM2000_REG_REVISON);
	dev_info(&i2c->dev, "revision %c\n", reg + 'A');

	filename = "wm2000_anc.bin";
	pdata = dev_get_platdata(&i2c->dev);
	wm2000->mclk_div = 1;
	wm2000->speech_clarity = 0;
	if (pdata) {
		wm2000->mclk_div = pdata->mclkdiv2;
		wm2000->speech_clarity = !pdata->speech_enh_disable;

		if (pdata->download_file)
			filename = pdata->download_file;
	}

	ret = request_firmware(&fw, filename, &i2c->dev);
	if (ret != 0) {
		dev_err(&i2c->dev, "Failed to acquire ANC data: %d\n", ret);
		goto out;
	}

	/* Pre-cook the concatenation of the register address onto the image */
	wm2000->anc_download_size = fw->size + 2;
	wm2000->anc_download = devm_kzalloc(&i2c->dev,
					    wm2000->anc_download_size,
					    GFP_KERNEL);
	if (wm2000->anc_download == NULL) {
		dev_err(&i2c->dev, "Out of memory\n");
		ret = -ENOMEM;
		goto out;
	}

	wm2000->anc_download[0] = 0x80;
	wm2000->anc_download[1] = 0x00;
	memcpy(wm2000->anc_download + 2, fw->data, fw->size);

	wm2000->anc_eng_ena = 0;
	wm2000->anc_active = 0;
	wm2000->spk_ena = 1;
	wm2000->incall_mode =0;
	wm2000->i2c = i2c;

	wm2000_reset(wm2000);

	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_wm2000, NULL, 0);

	if (!ret) {
		release_firmware(fw);
		return ret;
	}

out:
	release_firmware(fw);
out_regmap_exit:
	regmap_exit(wm2000->regmap);
err:
	devm_kfree(&i2c->dev, wm2000);
	return ret;
}

static __devexit int wm2000_i2c_remove(struct i2c_client *i2c)
{
	struct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);

	snd_soc_unregister_codec(&i2c->dev);
	regmap_exit(wm2000->regmap);

	return 0;
}

static const struct i2c_device_id wm2000_i2c_id[] = {
	{ "wm2000", 0 },
	{ }
};
MODULE_DEVICE_TABLE(i2c, wm2000_i2c_id);

static struct i2c_driver wm2000_i2c_driver = {
	.driver = {
		.name = "wm2000",
		.owner = THIS_MODULE,
	},
	.probe = wm2000_i2c_probe,
	.remove = __devexit_p(wm2000_i2c_remove),
	.id_table = wm2000_i2c_id,
};

static int __init wm2000_init(void)
{
	return i2c_add_driver(&wm2000_i2c_driver);
}
module_init(wm2000_init);

static void __exit wm2000_exit(void)
{
	i2c_del_driver(&wm2000_i2c_driver);
}
module_exit(wm2000_exit);

MODULE_DESCRIPTION("ASoC WM2000 driver");
MODULE_AUTHOR("Mark Brown <broonie@opensource.wolfonmicro.com>");
MODULE_LICENSE("GPL");
